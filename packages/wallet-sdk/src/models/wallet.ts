import { StacksNetwork } from '@stacks/network';
import { BIP32Interface, fromBase58 } from 'bip32';
import { getAddressFromPrivateKey } from '@stacks/transactions';
import { deriveDataPrivateKey, deriveStxPrivateKey } from '..';
import { deriveAccount, deriveLegacyConfigPrivateKey } from '../derive';
import { connectToGaiaHubWithConfig, getHubInfo } from '../utils';
import { Account } from './account';
import { fetchLegacyWalletConfig } from './legacy-wallet-config';
import { fetchWalletConfig, updateWalletConfig, WalletConfig } from './wallet-config';

/**
 * This object represents the keys that were derived from the root-level
 * keychain of a wallet.
 */
export interface WalletKeys {
  /** Used when generating app private keys, which encrypt app-specific data */
  salt: string;
  /** The private key associated with the root of a BIP39 keychain */
  rootKey: string;
  /** A private key used to encrypt configuration data */
  configPrivateKey: string;
}

export interface Wallet extends WalletKeys {
  /** The encrypted secret key */
  encryptedSecretKey: string;
  /** A list of accounts generated by this wallet */
  accounts: Account[];
}

export interface LockedWallet {
  encryptedSecretKey: string;
}

export const getRootNode = (wallet: Wallet) => {
  return fromBase58(wallet.rootKey);
};

export enum DerivationType {
  Wallet,
  Data,
  Unknown,
}

export const selectDerivationType = async ({
  username,
  rootNode,
  index,
  network,
}: {
  username: string;
  rootNode: BIP32Interface;
  index: number;
  network: StacksNetwork;
}): Promise<DerivationType> => {
  const nameInfo = await network.getNameInfo(username);
  let stxPrivateKey = deriveStxPrivateKey({ rootNode, index });
  let derivedAddress = getAddressFromPrivateKey(stxPrivateKey);
  console.log(derivedAddress, nameInfo.address);
  if (derivedAddress !== nameInfo.address) {
    // try data private key
    stxPrivateKey = deriveDataPrivateKey({
      rootNode,
      index,
    });
    derivedAddress = getAddressFromPrivateKey(stxPrivateKey);
    console.log(derivedAddress, nameInfo.address);
    if (derivedAddress !== nameInfo.address) {
      console.log(`unknown derivation path for ${username}`);
      return DerivationType.Unknown;
    } else {
      return DerivationType.Data;
    }
  } else {
    return DerivationType.Wallet;
  }
};

/**
 * Restore wallet accounts by checking for encrypted WalletConfig files,
 * stored in Gaia.
 *
 * This helps provide a better UX for users, so we can keep track of accounts they've
 * created, and usernames they've used.
 */
export async function restoreWalletAccounts({
  wallet,
  gaiaHubUrl,
  network,
}: {
  wallet: Wallet;
  gaiaHubUrl: string;
  network: StacksNetwork;
}): Promise<Wallet> {
  const hubInfo = await getHubInfo(gaiaHubUrl);
  const rootNode = getRootNode(wallet);
  const legacyGaiaConfig = connectToGaiaHubWithConfig({
    hubInfo,
    privateKey: deriveLegacyConfigPrivateKey(getRootNode(wallet)),
    gaiaHubUrl,
  });
  const currentGaiaConfig = connectToGaiaHubWithConfig({
    hubInfo,
    privateKey: wallet.configPrivateKey,
    gaiaHubUrl,
  });

  const [walletConfig, legacyWalletConfig] = await Promise.all([
    fetchWalletConfig({ wallet, gaiaHubConfig: currentGaiaConfig }),
    fetchLegacyWalletConfig({ wallet, gaiaHubConfig: legacyGaiaConfig }),
  ]);

  // Restore from existing config
  if (
    walletConfig &&
    walletConfig.accounts.length >= (legacyWalletConfig?.identities.length || 0)
  ) {
    const newAccounts = await Promise.all(
      walletConfig.accounts.map(async (account, index) => {
        let existingAccount = wallet.accounts[index];
        let stxDerivationType = DerivationType.Wallet;
        if (account.username) {
          const stxDerivationTypeForUsername = await selectDerivationType({
            username: account.username,
            rootNode,
            index,
            network,
          });
          if (stxDerivationTypeForUsername === DerivationType.Unknown) {
            delete account.username;
          } else {
            stxDerivationType = stxDerivationTypeForUsername;
          }
        }
        if (!existingAccount) {
          existingAccount = deriveAccount({
            rootNode,
            index,
            salt: wallet.salt,
            stxDerivationType,
          });
        }
        return {
          ...existingAccount,
          username: account.username,
        };
      })
    );

    return {
      ...wallet,
      accounts: newAccounts,
    };
  }

  // Restore from legacy config, and upload a new one
  if (legacyWalletConfig) {
    const newAccounts = await Promise.all(
      legacyWalletConfig.identities.map(async (identity, index) => {
        let existingAccount = wallet.accounts[index];
        let stxDerivationType = DerivationType.Wallet;
        if (identity.username) {
          const stxDerivationTypeForUsername = await selectDerivationType({
            username: identity.username,
            rootNode,
            index,
            network,
          });
          if (stxDerivationTypeForUsername === DerivationType.Unknown) {
            delete identity.username;
          } else {
            stxDerivationType = stxDerivationTypeForUsername;
          }
        }
        if (!existingAccount) {
          existingAccount = deriveAccount({
            rootNode,
            index,
            salt: wallet.salt,
            stxDerivationType,
          });
        }
        return {
          ...existingAccount,
          username: identity.username,
        };
      })
    );

    const meta: Record<string, boolean> = {};
    if (legacyWalletConfig.hideWarningForReusingIdentity) {
      meta.hideWarningForReusingIdentity = true;
    }
    const newConfig: WalletConfig = {
      accounts: legacyWalletConfig.identities.map(identity => ({
        username: identity.username,
        apps: identity.apps,
      })),
      meta,
    };

    await updateWalletConfig({
      wallet,
      walletConfig: newConfig,
      gaiaHubConfig: currentGaiaConfig,
    });

    return {
      ...wallet,
      accounts: newAccounts,
    };
  }

  return wallet;
}
